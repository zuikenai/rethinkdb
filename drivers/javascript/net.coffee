# # Network (net.coffee)
#
# This module handles network and protocol related functionality for
# the driver. The classes defined here are:
#
# - `Connection`, which is an EventEmitter and the base class for
# - `TcpConnection`, the standard driver connection
# - `HttpConnection`, the connection type used by the webui
#

# ### Imports
#
# The [net module](http://nodejs.org/api/net.html) is the low-level
# networking library Node.js provides. We need it for `TCPConnection`
# objects
net = require('net')

# The [events module](http://nodejs.org/api/events.html) is a core
# Node.js module that provides the ability for objects to emit events,
# and for callbacks to be attached to those events.
events = require('events')

# The [util module](util.html) contains utility methods used several
# places in the driver
util = require('./util')

# The [errors module](errors.html) contains exceptions thrown by the driver
err = require('./errors')

# The [cursors module](cursors.html) contains data structures used to
# iterate over large result sets or infinite streams of data from the
# database (changefeeds).
cursors = require('./cursor')

# The `proto-def` module is an autogenerated file full of protocol
# definitions used to communicate to the RethinkDB server (basically a
# ton of human readable names for magic numbers).
#
# It is created by the python script `convert_protofile` in the
# `drivers` directory (one level up from this file) by converting a
# protocol buffers definition file into a JavaScript file. To generate
# the `proto-def.js` file, see the instructions in the
# [README](./index.html#creating-the-proto-defjs)
#
# Note that it's a plain JavaScript file, not a CoffeeScript file.
protodef = require('./proto-def')

# Each version of the protocol has a magic number specified in
# `./proto-def.coffee`. The most recent version is 3. Generally the
# official driver will always be updated to the newest version of the
# protocol, though RethinkDB supports older versions for some time.
protoVersion = protodef.VersionDummy.Version.V0_3

# We are using the JSON protocol for RethinkDB, which is the most
# recent version. The older protocol is based on Protocol Buffers, and
# is deprecated.
protoProtocol = protodef.VersionDummy.Protocol.JSON

# The `QueryType` definitions are used to control at a high level how
# we interact with the server. So we can `START` a new connection,
# `STOP` an existing connection, `CONTINUE` receiving results from an
# existing connection, or notify the server we won't be waiting for a
# reply immediately with `NOREPLY_WAIT`.
protoQueryType = protodef.Query.QueryType

# The server can respond to queries in several ways. These are the
# definitions for the response types.
protoResponseType = protodef.Response.ResponseType

# The [ast module](ast.html) contains the bulk of the api exposed by
# the driver. It's defines how you can create ReQL queries, and
# handles serializing those queries into JSON to be transmitted over
# the wire to the database server.
r = require('./ast')

# We use the [bluebird](https://github.com/petkaantonov/bluebird)
# third-party module to provide a promise implementation for the
# driver.
Promise = require('bluebird')

# These are some functions we import directly from the `util` module
# for convenience.
ar = util.ar
varar = util.varar
aropt = util.aropt
mkAtom = util.mkAtom
mkErr = util.mkErr

# ### Connection
#
# Connection is the base class for both `TCPConnection` and
# `HTTPConnection`. Applications using this driver will need to get a
# connection object to be able to query the server.
#
# Connection is a subclass of
# [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter),
# and it will emit the following events:
#
# - `"connect"` is emitted by the subclasses `TcpConnection` and
#   `HTTPConnection` when they connect to the server successfully.
# - `"error"` is emitted when protocol level errors occur (notably
#    not query errors! Those are returned as arguments to the
#    callback the user provides.) `"error"` will also be accompanied
#    by a message indicating what went wrong.
# - `"close"` is emitted when the connection is closed either through
#    an error or by the user calling `connection.close()` explicitly
# - `"timeout"` will be emitted by the `TCPConnection` subclass if the
#    underlying socket times out for any reason.
class Connection extends events.EventEmitter

    # These are the default hostname and port used by RethinkDB
    DEFAULT_HOST: 'localhost'
    DEFAULT_PORT: 28015
    # By default, RethinkDB doesn't use an authorization key.
    DEFAULT_AUTH_KEY: ''
    # Each connection has a timeout (in seconds) for the initial handshake with the
    # server. Note that this is not a timeout for queries to return
    # results.
    DEFAULT_TIMEOUT: 20 # In seconds

    # #### Connection constructor
    constructor: (host, callback) ->
        # We need to set the defaults if the user hasn't supplied anything.
        if typeof host is 'undefined'
            host = {}
        # It's really convenient to be able to pass just a hostname to
        # connect, since that's the thing that is most likely to vary
        # (default ports, no auth key, default connection timeout are
        # all common). We just detect that case and wrap it.
        else if typeof host is 'string'
            host = {host: host}

        # Here we set all of the connection parameters to their defaults.
        @host = host.host || @DEFAULT_HOST
        @port = host.port || @DEFAULT_PORT

        # One notable exception to defaulting is the db name. If the
        # user doesn't specify it, we leave it undefined. On the
        # server side, if no database is specified for a table, the
        # database will default to `"test"`.
        @db = host.db # left undefined if this is not set

        @authKey = host.authKey || @DEFAULT_AUTH_KEY
        @timeout = host.timeout || @DEFAULT_TIMEOUT

        # The protocol allows for responses to queries on the same
        # connection to be returned interleaved. When a query is run
        # with this connection, an entry is added to
        # `@outstandingCallbacks`. The key is the query token, and the
        # value is an object with the following fields:
        #
        # - **cb**: The callback to invoke when a query returns another
        #   batch of results
        # - **root**: a subclass of `TermBase` (defined in the
        #   [ast module](ast.html)) representing the query being run.
        # - **opts**: global options passed to `.run`.
        #
        # Once the server returns a response, one of two fields may be
        # added to the entry for that query depending on what comes
        # back (this is done in `_processResponse`):
        #
        # - **cursor**: is set to a `Cursor` object (defined in the
        #   [cursor module](cursor.html)) if the server
        #   replies with `SUCCESS_PARTIAL`. This happens when a
        #   result is too large to send back all in one batch. The
        #   `Cursor` allows fetching results lazily as they're needed.
        # - **feed**: is set to a `Feed` object (defined in the
        #   [cursor module](cursor.html)). This is very similar to a `Cursor`,
        #   except that it is potentially infinite. Changefeeds are a way
        #   for the server to notify the client when a change occurs to
        #   the results of a query the user wants to watch.
        #
        # Any other responses are considered "done" and don't have any
        # further results to fetch from the server. At that time the
        # query token is deleted from `@outstandingCallbacks` since we
        # don't expect any more results using that token.
        @outstandingCallbacks = {}

        # Each query to the server requires a unique token (per
        # connection). `nextToken` is incremented every time we issue
        # a new query
        @nextToken = 1

        # `@open` and `@closing` are used to record changes in the
        # connection state. A connection is open after the handshake
        # is successfully completed, and it becomes closed after the
        # server confirms the connection is closed.
        @open = false
        # `@closing` is true when the `conn.close()` method is called,
        # and becomes false again just before the callback provided to
        # `close` is called.
        @closing = false

        # We create a [Buffer](http://nodejs.org/api/buffer.html)
        # object to receive all bytes coming in on this
        # connection. The buffer is modified in the `_data` method
        # (which is called whenever data comes in over the network on
        # this connection), and it is also modified by the handshake
        # callback that's defined in the `TCPConnection` constructor.
        @buffer = new Buffer(0)

        @_events = @_events || {}

        # Now we set up two callbacks, one to run on successful
        # connection, and the other to run if we fail to connect to
        # the server. They listen to the `"connect"` and `"error"`
        # events respectively. If successful, we set `@open` to
        # `true`, otherwise we pass an error to the connection
        # callback that was passed to the constructor (`callback`)
        errCallback = (e) =>
            @removeListener 'connect', conCallback
            if e instanceof err.RqlDriverError
                callback e
            else
                callback new err.RqlDriverError "Could not connect to #{@host}:#{@port}.\n#{e.message}"
        @once 'error', errCallback

        conCallback = =>
            @removeListener 'error', errCallback
            @open = true
            callback null, @
        @once 'connect', conCallback


    # #### Connection _data method
    #
    # This method is responsible for parsing responses from the server
    # after the initial handshake is over. It reads the token number
    # of the response (so we know which query is being responded to),
    # and the response length, then parses the rest of the response as
    # JSON.
    _data: (buf) ->
        # We extend the current buffer with the contents of `buf` that
        # we got from the server.
        @buffer = Buffer.concat([@buffer, buf])

        # The first 8 bytes in a response are the token number of the
        # query the server is responding to. The next 4 bytes indicate
        # how long the response will be. So if the response isn't at
        # least 12 bytes long, there's nothing else to do.
        while @buffer.length >= 12
            # When a query is sent to the server, we write out the
            # token in a way that can be read back later as a native
            # integer. Since Node buffers don't have a method like
            # `readUInt64LE`, we're forced to emulate it ourselves.
            token = @buffer.readUInt32LE(0) + 0x100000000 * @buffer.readUInt32LE(4)

            # Next up is the response length. The protocol dictates
            # this must be a 32 bit unsigned integer in little endian
            # byte order.
            responseLength = @buffer.readUInt32LE(8)
            # This ensures that the responseLength is less than or
            # equal to the amount of data we have in the buffer
            # (including the token and response length itself). If the
            # buffer doesn't have enough data in it, we just break
            # out. More data will be coming later, and it will be
            # added to the end of the buffer, so we'll wait until the
            # full response is available.
            unless @buffer.length >= (12 + responseLength)
                break

            # Since we have enough data, we slice it out of the
            # buffer, and parse it as JSON.
            responseBuffer = @buffer.slice(12, responseLength + 12)
            response = JSON.parse(responseBuffer)

            # Now it's off to `_processResponse` where the data is
            # converted to a format the user will be able to work
            # with, error responses are detected etc.
            @_processResponse response, token

            # Finally, we truncate the buffer to the end of the
            # current response. The buffer may already be queuing up a
            # new response, so it's never safe to clear it or create a
            # new one.
            @buffer = @buffer.slice(12 + responseLength)

    # #### Connection _delQuery method
    #
    # This method just removes the entry in `@outstandingCallbacks`
    # for a given token. It's called whenever a response doesn't
    # return a cursor, a cursor is completely consumed, or the query
    # encounters an error.
    _delQuery: (token) ->
        delete @outstandingCallbacks[token]

    # #### Connection _processResponse method
    #
    # This method is contains the main logic for taking different
    # actions based on the response type. It receives the response as
    # an object (parsed from the JSON coming over the wire), and the
    # token for the query the response corresponds to.
    _processResponse: (response, token) ->
        # For brevity the wire format specifies that the profile key
        # is "p". We give it a more readable variable name here.
        profile = response.p
        # First we need to check if we're even expecting a response
        # for this token. If not it's an error.
        if @outstandingCallbacks[token]?
            {cb:cb, root:root, cursor: cursor, opts: opts, feed: feed} = @outstandingCallbacks[token]
            # Some results for queries are not returned all at once,
            # but in chunks. The driver takes care of making sure the
            # user doesn't see this, and uses `Cursor`s to take
            # multiple responses and make them into one long stream of
            # query results.
            #
            # Depending on the type of result, and whether this is the
            # first response for this token, we may or may not have a
            # cursor defined for this token. If we do have a cursor
            # defined already, we add this response to the cursor.
            if cursor?
                cursor._addResponse(response)

                # `cursor._addResponse` will check if this response is
                # the last one for this token, and if so will set its
                # `cursor._endFlag` to true. If this is the last
                # response for this query and we aren't waiting on any
                # other responses for this cursor (if, for example, we
                # get the responses out of order), then we remove this
                # token's entry in `@outstandingCallbacks`.
                if cursor._endFlag && cursor._outstandingRequests is 0
                    @_delQuery(token)

            # Similar to cursors, we may or may not have a feed object
            # already for this token. The feed object is created on
            # the first response received, so we may not have one if
            # this is the first response for this token. (Or we may
            # not have one if this isn't a query that returns a feed)
            else if feed?
                # Cursor and Feed have a shared implementation, so the
                # logic for adding a response to the feed and deciding
                # whether to delete the token from
                # `@outstandingRequests` is the same.
                feed._addResponse(response)

                if feed._endFlag && feed._outstandingRequests is 0
                    @_delQuery(token)
            # Next we check if we have a callback registered for this
            # token. In [ast](ast.html) we always provide `_start`
            # with a wrapped callback function, so this may as well be
            # an else branch.
            else if cb?
                # The protocol (again for brevity) puts the response
                # type into a key called "t". What we do next depends
                # on that value. We'll be comparing it to the values
                # in the `proto-def` module, in `protoResponseType`.
                switch response.t
                    # ##### Error responses
                    when protoResponseType.COMPILE_ERROR
                        # Compile errors happen during parsing and
                        # type checking the query on the server
                        # side. An example is passing too many
                        # arguments to a function.  We pass an error
                        # object that includes the backtrace from the
                        # response and the original query
                        # (`root`). Then we delete the token from
                        # `@outstandingCallbacks`.
                        cb mkErr(err.RqlCompileError, response, root)
                        @_delQuery(token)
                    when protoResponseType.CLIENT_ERROR
                        # Client errors are returned when the client
                        # is buggy. This can happen if a query isn't
                        # serialized right, or the handshake is done
                        # incorrectly etc. Hopefully end users of the
                        # driver should never see these.
                        cb mkErr(err.RqlClientError, response, root)
                        @_delQuery(token)
                    when protoResponseType.RUNTIME_ERROR
                        # Runtime errors are the most common type of
                        # error. They happen when something goes wrong
                        # that can only be determined by running the
                        # query. For example, if you try to get the
                        # value of a field in an object that doesn't
                        # exist.
                        cb mkErr(err.RqlRuntimeError, response, root)
                        @_delQuery(token)
                    # ##### Success responses
                    when protoResponseType.SUCCESS_ATOM
                        # `SUCCESS_ATOM` is returned when the query
                        # was successful and returned a single ReQL
                        # data type. The `mkAtom` function from the
                        # [util module](util.html) converts all
                        # pseudotypes in this response to their
                        # corresponding native types
                        response = mkAtom response, opts
                        # If the response is an array, we patch it a
                        # bit so it can be used as a stream.
                        if Array.isArray response
                            response = cursors.makeIterable response
                        # If there's a profile available, we nest the
                        # response slightly differently before passing
                        # it to the callback for this token.
                        if profile?
                            response = {profile: profile, value: response}
                        cb null, response
                        # The `SUCCESS_ATOM` response means there will
                        # be no further results for this query, so we
                        # remove it from `@outstandingCallbacks`
                        @_delQuery(token)
                    when protoResponseType.SUCCESS_PARTIAL
                        # `SUCCESS_PARTIAL` indicates the client
                        # should create a cursor and request more data
                        # from the server when it's ready by sending a
                        # `CONTINUE` query with the same token. So, we
                        # create a new Cursor for this token, and add
                        # it to the object stored in
                        # `@outstandingCallbacks`
                        cursor = new cursors.Cursor @, token, opts, root
                        @outstandingCallbacks[token].cursor = cursor
                        # Again, if we have profile information, we
                        # wrap the result given to the callback.  In
                        # either case, we need to add the response to
                        # the new Cursor.
                        if profile?
                            cb null, {profile: profile, value: cursor._addResponse(response)}
                        else
                            cb null, cursor._addResponse(response)
                    when protoResponseType.SUCCESS_SEQUENCE
                        # The `SUCCESS_SEQUENCE` response is sent when
                        # a cursor or feed is complete, and this is
                        # the last response that will be received for
                        # this token. Often, however, the entire
                        # result for a query fits within the initial
                        # batch. In this case, we never see a
                        # `SUCCESS_PARTIAL` response, so there is no
                        # existing Cursor to add the response to. So,
                        # that's what we do here, create a new Cursor,
                        # and delete the token from the
                        # `@outstandingCallbacks`.
                        #
                        # Note that qeries that have already received
                        # a `SUCCESS_PARTIAL` will not be handled
                        # here. They will be handled when we check for
                        # `cursor?` in the conditional up above. In
                        # that branch, we call cursor._addResponse,
                        # which takes care of checking if we received
                        # a `SUCCESS_SEQUENCE`. So this code only gets
                        # executed when the first batch on a cursor is
                        # also our last.
                        cursor = new cursors.Cursor @, token, opts, root
                        @_delQuery(token)
                        if profile?
                            cb null, {profile: profile, value: cursor._addResponse(response)}
                        else
                            cb null, cursor._addResponse(response)
                    when protoResponseType.SUCCESS_FEED
                        # The `SUCCESS_FEED` response is sent by the
                        # server to indicate that the response
                        # represents a changefeed. This works just
                        # like a cursor (sending `CONTINUE` to get
                        # more results etc), except that it is
                        # potentially infinite.
                        #
                        # The main difference here is that we create a
                        # `Feed` object vs. a `Cursor` object, and we
                        # set the `feed` key for this token in
                        # `@outstandingCallbacks` instead of the
                        # `cursor` key.
                        feed = new cursors.Feed @, token, opts, root
                        @outstandingCallbacks[token].feed = feed
                        if profile?
                            cb null, {profile: profile, value: feed._addResponse(response)}
                        else
                            cb null, feed._addResponse(response)
                    when protoResponseType.SUCCESS_ATOM_FEED
                        # `SUCCESS_ATOM_FEED` is just like
                        # `SUCCESS_FEED`, except that it indicates the
                        # changes coming back will all be for a single
                        # document, vs. changes from potentially many
                        # documents. So for example, a query like
                        # `r.table('foo').get('bar').changes()` will
                        # return a `SUCCESS_ATOM_FEED` response
                        feed = new cursors.AtomFeed @, token, opts, root
                        @outstandingCallbacks[token].feed = feed
                        if profile?
                            cb null, {profile: profile, value: feed._addResponse(response)}
                        else
                            cb null, feed._addResponse(response)
                    when protoResponseType.WAIT_COMPLETE
                        # The `WAIT_COMPLETE` response is sent by the
                        # server after all queries executed with the
                        # optarg `noReply: true` have completed. No
                        # data is returned, so the callback is just provided `null`
                        @_delQuery(token)
                        cb null, null
                    else
                        cb new err.RqlDriverError "Unknown response type"
        else
            # Throw an error if we get a response with a token not
            # found in `@outstandingCallbacks`
            @emit 'error', new err.RqlDriverError "Unexpected token #{token}."

    # #### Connection close method
    #
    # A public method that closes the connection. See [API docs for
    # close](http://rethinkdb.com/api/javascript/close/).
    close: (varar 0, 2, (optsOrCallback, callback) ->
        # First determine which argument combination this method was
        # called with, and set the callback and options appropriately.
        if callback?
            opts = optsOrCallback
            unless Object::toString.call(opts) is '[object Object]'
                throw new err.RqlDriverError "First argument to two-argument `close` must be an object."
            cb = callback
        else if Object::toString.call(optsOrCallback) is '[object Object]'
            opts = optsOrCallback
            cb = null
        else if typeof optsOrCallback is 'function'
            opts = {}
            cb = optsOrCallback
        else
            opts = optsOrCallback
            cb = null

        for own key of opts
            # Currently, only one optional argument is accepted by
            # `.close`: whether or not to wait for completion of all
            # outstanding `noreply` queries. So we throw an error if
            # anything else is passed.
            unless key in ['noreplyWait']
                throw new err.RqlDriverError "First argument to two-argument `close` must be { noreplyWait: <bool> }."

        # Next we set `@closing` to true. It will be set false once
        # the promise resolves. The `isOpen` method takes this
        # variable into account.
        @closing = true

        # Should we wait for all outstanding `noreply` writes before
        # considering the connection closed?
        #
        # - if the options object doesn't have a `noreplyWait` key, we
        # default to `true`.
        # - if we do have a `noreplyWait` key, then use that value
        # - if this connection isn't `@open`, then this is all moot
        noreplyWait = ((not opts.noreplyWait?) or opts.noreplyWait) and @open

        # This creates a promise that can either do one of two things:
        # 1. If we are waiting for all outstanding `noreply` queries
        # to be done, then this promise is resolved when that query
        # completes.
        # 2. If we aren't waiting, this promise is resolved immediately
        #
        # In either case, the callback provided to `.close` is invoked
        # after this promise is resolved.
        new Promise( (resolve, reject) =>
            wrappedCb = (err, result) =>
                @open = false
                @closing = false
                @cancel()
                if err?
                    reject err
                else
                    resolve result

            if noreplyWait
                @noreplyWait(wrappedCb)
            else
                wrappedCb()
        ).nodeify cb
    )

    noreplyWait: varar 0, 1, (callback) ->
        unless @open
            return new Promise( (resolve, reject) ->
                reject(new err.RqlDriverError "Connection is closed.")
            ).nodeify callback

        # Assign token
        token = @nextToken++

        # Construct query
        query = {}
        query.type = protoQueryType.NOREPLY_WAIT
        query.token = token

        # Save callback
        new Promise( (resolve, reject) =>
            wrappedCb = (err, result) ->
                if (err)
                    reject(err)
                else
                    resolve(result)
            @outstandingCallbacks[token] = {cb:wrappedCb, root:null, opts:null}
            @_sendQuery(query)
        ).nodeify callback

    cancel: ar () ->
        response = {t:protoResponseType.RUNTIME_ERROR,r:["Connection is closed."],b:[]}
        for own key, value of @outstandingCallbacks
            if value.cursor?
                value.cursor._addResponse(response)
            else if value.feed?
                value.feed._addResponse(response)
            else if value.cb?
                value.cb mkErr(err.RqlRuntimeError, response, value.root)

        @outstandingCallbacks = {}

    reconnect: (varar 0, 2, (optsOrCallback, callback) ->
        if callback?
            opts = optsOrCallback
            cb = callback
        else if typeof optsOrCallback is "function"
            opts = {}
            cb = optsOrCallback
        else
            if optsOrCallback?
                opts = optsOrCallback
            else
                opts = {}
            cb = callback

        new Promise( (resolve, reject) =>
            closeCb = (err) =>
                @rawSocket.removeAllListeners()
                @rawSocket = null # The rawSocket has been closed
                @constructor.call @,
                    host:@host,
                    port:@port
                    timeout:@timeout,
                    authKey:@authKey
                , (err, conn) ->
                    if err?
                        reject err
                    else
                        resolve conn
            @close(opts, closeCb)
        ).nodeify cb
    )

    use: ar (db) ->
        @db = db

    isOpen: () ->
        @open and not @closing

    _start: (term, cb, opts) ->
        unless @open then throw new err.RqlDriverError "Connection is closed."

        # Assign token
        token = @nextToken++

        # Construct query
        query = {}
        query.global_optargs = {}
        query.type = protoQueryType.START
        query.query = term.build()
        query.token = token
        # Set global options
        for own key, value of opts
            query.global_optargs[util.fromCamelCase(key)] = r.expr(value).build()

        if @db?
            query.global_optargs['db'] = r.db(@db).build()

        if opts.useOutdated?
            query.global_optargs['use_outdated'] = r.expr(!!opts.useOutdated).build()

        if opts.noreply?
            query.global_optargs['noreply'] = r.expr(!!opts.noreply).build()

        if opts.profile?
            query.global_optargs['profile'] = r.expr(!!opts.profile).build()

        # Save callback
        if (not opts.noreply?) or !opts.noreply
            @outstandingCallbacks[token] = {cb:cb, root:term, opts:opts}

        @_sendQuery(query)

        if opts.noreply? and opts.noreply and typeof(cb) is 'function'
            cb null # There is no error and result is `undefined`

    _continueQuery: (token) ->
        unless @open then throw new err.RqlDriverError "Connection is closed."

        query =
            type: protoQueryType.CONTINUE
            token: token

        @_sendQuery(query)

    _endQuery: (token) ->
        unless @open then throw new err.RqlDriverError "Connection is closed."

        query =
            type: protoQueryType.STOP
            token: token

        @_sendQuery(query)

    _sendQuery: (query) ->
        # Serialize query to JSON
        data = [query.type]
        if !(query.query is undefined)
            data.push(query.query)
            if query.global_optargs? and Object.keys(query.global_optargs).length > 0
                data.push(query.global_optargs)

        @_writeQuery(query.token, JSON.stringify(data))


class TcpConnection extends Connection
    @isAvailable: () -> !(process.browser)

    constructor: (host, callback) ->
        unless TcpConnection.isAvailable()
            throw new err.RqlDriverError "TCP sockets are not available in this environment"

        super(host, callback)

        @rawSocket = net.connect @port, @host
        @rawSocket.setNoDelay()

        timeout = setTimeout( (()=>
            @rawSocket.destroy()
            @emit 'error', new err.RqlDriverError "Handshake timedout"
        ), @timeout*1000)

        @rawSocket.once 'error', => clearTimeout(timeout)

        @rawSocket.once 'connect', =>
            # Initialize connection with magic number to validate version
            version = new Buffer(4)
            version.writeUInt32LE(protoVersion, 0)

            auth_buffer = new Buffer(@authKey, 'ascii')
            auth_length = new Buffer(4)
            auth_length.writeUInt32LE(auth_buffer.length, 0)

            # Send the protocol type that we will be using to communicate with the server
            protocol = new Buffer(4)
            protocol.writeUInt32LE(protoProtocol, 0)

            @rawSocket.write Buffer.concat([version, auth_length, auth_buffer, protocol])

            # Now we have to wait for a response from the server
            # acknowledging the new connection
            handshake_callback = (buf) =>
                @buffer = Buffer.concat([@buffer, buf])
                for b,i in @buffer
                    if b is 0
                        @rawSocket.removeListener('data', handshake_callback)

                        status_buf = @buffer.slice(0, i)
                        @buffer = @buffer.slice(i + 1)
                        status_str = status_buf.toString()

                        clearTimeout(timeout)
                        if status_str == "SUCCESS"
                            # We're good, finish setting up the connection
                            @rawSocket.on 'data', (buf) => @_data(buf)

                            @emit 'connect'
                            return
                        else
                            @emit 'error', new err.RqlDriverError "Server dropped connection with message: \"" + status_str.trim() + "\""
                            return


            @rawSocket.on 'data', handshake_callback

        @rawSocket.on 'error', (args...) =>
            if @isOpen()
                @close({noreplyWait:false})
            @emit 'close'

        @rawSocket.on 'close', =>
            if @isOpen()
                @close({noreplyWait: false})
            @emit 'close'

        # In case the raw socket timesout, we close it and re-emit the event for the user
        @rawSocket.on 'timeout', => @open = false; @emit 'timeout'

    close: (varar 0, 2, (optsOrCallback, callback) ->
        if callback?
            opts = optsOrCallback
            cb = callback
        else if Object::toString.call(optsOrCallback) is '[object Object]'
            opts = optsOrCallback
            cb = null
        else if typeof optsOrCallback is "function"
            opts = {}
            cb = optsOrCallback
        else
            opts = {}

        new Promise( (resolve, reject) =>
            wrappedCb = (error, result) =>
                @rawSocket.once "close", =>
                    if error?
                        reject error
                    else
                        resolve result

                @rawSocket.end()

            TcpConnection.__super__.close.call(@, opts, wrappedCb)
        ).nodeify cb
    )

    cancel: () ->
        @rawSocket.destroy()
        super()

    _writeQuery: (token, data) ->
        tokenBuf = new Buffer(8)
        tokenBuf.writeUInt32LE(token & 0xFFFFFFFF, 0)
        tokenBuf.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)
        @rawSocket.write tokenBuf
        @write new Buffer(data)

    write: (chunk) ->
        lengthBuffer = new Buffer(4)
        lengthBuffer.writeUInt32LE(chunk.length, 0)
        @rawSocket.write lengthBuffer
        @rawSocket.write chunk

class HttpConnection extends Connection
    DEFAULT_PROTOCOL: 'http'

    @isAvailable: -> typeof XMLHttpRequest isnt "undefined"
    constructor: (host, callback) ->
        unless HttpConnection.isAvailable()
            throw new err.RqlDriverError "XMLHttpRequest is not available in this environment"

        super(host, callback)

        protocol = if host.protocol is 'https' then 'https' else @DEFAULT_PROTOCOL
        url = "#{protocol}://#{@host}:#{@port}#{host.pathname}ajax/reql/"
        xhr = new XMLHttpRequest
        xhr.open("POST", url+"open-new-connection", true)
        xhr.responseType = "arraybuffer"

        xhr.onreadystatechange = (e) =>
            if xhr.readyState is 4
                if xhr.status is 200
                    @_url = url
                    @_connId = (new DataView xhr.response).getInt32(0, true)
                    @emit 'connect'
                else
                    @emit 'error', new err.RqlDriverError "XHR error, http status #{xhr.status}."
        xhr.send()

        @xhr = xhr # We allow only one query at a time per HTTP connection

    cancel: ->
        if @_connId? # @connId is null if the connection was previously closed/cancel
            @xhr.abort()
            xhr = new XMLHttpRequest
            xhr.open("POST", "#{@_url}close-connection?conn_id=#{@_connId}", true)

            # We ignore the result, but Firefox doesn't. Without this line it complains
            # about "No element found" when trying to parse the response as xml.
            xhr.responseType = "arraybuffer"

            xhr.send()

            @_url = null
            @_connId = null
            super()

    close: (varar 0, 2, (optsOrCallback, callback) ->
        if callback?
            opts = optsOrCallback
            cb = callback
        else if Object::toString.call(optsOrCallback) is '[object Object]'
            opts = optsOrCallback
            cb = null
        else
            opts = {}
            cb = optsOrCallback
        unless not cb? or typeof cb is 'function'
            throw new err.RqlDriverError "Final argument to `close` must be a callback function or object."

        # This would simply be super(opts, wrappedCb), if we were not in the varar
        # anonymous function
        HttpConnection.__super__.close.call(this, opts, cb)
    )

    _writeQuery: (token, data) ->
        buf = new Buffer(encodeURI(data).split(/%..|./).length - 1 + 8)
        buf.writeUInt32LE(token & 0xFFFFFFFF, 0)
        buf.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)
        buf.write(data, 8)
        @write buf, token

    write: (chunk, token) ->
        xhr = new XMLHttpRequest
        xhr.open("POST", "#{@_url}?conn_id=#{@_connId}", true)
        xhr.responseType = "arraybuffer"

        xhr.onreadystatechange = (e) =>
            if xhr.readyState is 4 and xhr.status is 200
                # Convert response from ArrayBuffer to node buffer

                buf = new Buffer(b for b in (new Uint8Array(xhr.response)))
                @_data(buf)

        xhr.onerror = (e) =>
            @outstandingCallbacks[token].cb(new Error("This HTTP connection is not open"))

        # Convert the chunk from node buffer to an ArrayBufferView (Uint8Array)
        # Passing an ArrayBuffer in xhr.send is deprecated
        view = new Uint8Array(chunk.length)
        i = 0
        while i < chunk.length
            view[i] = chunk[i]
            i++
        xhr.send view
        @xhr = xhr # We allow only one query at a time per HTTP connection

module.exports.isConnection = (connection) ->
    return connection instanceof Connection

# The main function of this module
module.exports.connect = varar 0, 2, (hostOrCallback, callback) ->
    if typeof hostOrCallback is 'function'
        host = {}
        callback = hostOrCallback
    else
        host = hostOrCallback

    new Promise( (resolve, reject) ->
        create_connection = (host, callback) =>
            if TcpConnection.isAvailable()
                new TcpConnection host, callback
            else if HttpConnection.isAvailable()
                new HttpConnection host, callback
            else
                throw new err.RqlDriverError "Neither TCP nor HTTP avaiable in this environment"

        wrappedCb = (err, result) ->
            if (err)
                reject(err)
            else
                resolve(result)
        create_connection(host, wrappedCb)
    ).nodeify callback
